---
title: '코드 계약'
---

- 계약에 의한 프로그래밍 / 디자인은 이전 절에서 논의한 개념들 중 일부를 공식화하는 원칙이다.
    - 다른 사람들이 어떻게 코드를 사용할지
    - 코드가 무엇을 할 것으로 기대할 수 있는지
- 서로 다른 코드 간의 상호작용을 마치 계약처럼 생각한다.
- 용어에 대한 세가지 범주
    1. 선결 조건 - 코드를 호출하기 전에 사실이어야 하는 것.
    2. 사후 조건 - 코드가 호출된 후에 사실이어야 하는 것. 
    3. 불변 사항 - 코드가 호출되기 전과 후에 상태 비교 후 변경되지 않아야하는 사항.
- 계약에 의한 프로그래밍을 들어본적이 없거나, 해본적 없다고 하더라도 코드를 작성하면 어떤 종류의 계약을 맺는 것이라고 봐도 무방하다.
    - 해당 코드에 대한 기대를 갖게 하기 때문이다.

### 3.3.1 계약의 세부 조항

- 대부분의 사람들은 계약서를 읽어야 한다는 점은 알고 있다
    - 읽지 않고 시간이 지난 뒤, 알지 못했던 세부 조항이 문제가 될 수 있다.
- 코드에서도 명확한 부분과 세부 조항들이 있다
    - 계획의 명확한 부분
        - 함수와 클래스 이름 - 호출할 때 모르면 사용할 수 없다.
        - 인자 유형 - 호출할 때 잘못 사용하면 컴파일조차 되지 않는다.
        - 반환 유형 - 일치하지 않는 유형을 사용하며녀 컴파일되지 않는다.
        - 검사 예외 - 호출하는 코드가 처리하지 않는다면 컴파일되지 않는다.
    - 세부 조항
        - 주석문과 문서 - 실제 계약처럼 꼼꼼하게 읽어봐야하지만, 잘 읽지 않는다.
        - 비검사 예외 - 주석에 나열된 예외는 세부 조항이며, 종종 생략되기도 한다. ( 비검사 예외를 일으키지만 문서화를 생략한 경우 )

### 3.3.2 세부 조항에 너무 의존하지 말라

- 코드 계약을 전달할 때 세부 조항을 사용하는 것은 신뢰할 만한 방법이 아니다.
- 어쩔 수 없이 저품질의 코드 사용하여 이상하게 동작하는 코드를 만들었을 때
    - 문서화된 세부 조항이 필요하고 개발자들에게 읽도록 해야한다.
- 명확하지 않을 수도 있는 사항들을 문서화하는 것은 일반적으로 좋은 생각이지만, 너무 많이 의존하지 않는 것이 최선의 방법이다.
    - 분명한 항목을 통해 명확하게 설명하는 것이 가능하다면 더 바람직하다.
- 다른 개발자가 코드를 올바르게 사용하기 위해 애초에 발생 자체가 불가능하도록 만드는 것이 좋다.

```java
class UserSettings { 
    private UserSettings() {...}
    // 프라이빗 생성자를 만들어, 이 코드를 사용하는 다른 개발자는 create()밖에 사용할 수 밖에 없도록
    static UserSettings? create(File location) { 
        UserSettings settings = new UserSettings();
        if (!settings.loadSettings(location)) {
            return null;
        }
        settings.init();
        return settings;
    }

    private Boolean loadSettings(File location) {...}

    private void init() {...}
    // 클래스 상태를 변경하는 함수는 전부 private

    Color? getUiColor() {...}
    // 기존에 null값이 loadSettings()이 불렸는지, init이 되었는지에 의미를 가질 수 있었지만 
    // 수정 이후 사용자가 색상을 선택하지 않았다는 의미만을 갖는다. 
}